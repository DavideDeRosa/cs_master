from threading import Thread
from concurrent import futures
import grpc
import chat_pb2, chat_pb2_grpc
from time import sleep
from datetime import datetime
import sys

TIME_FORMAT = '%H:%M'

"""
Implementing the ChattingServiceServicer class that handles the Chat RPC, generated by the grpctools
"""
class ChattingServiceServicer(chat_pb2_grpc.ChattingServiceServicer):
    def __init__(self, name: str) -> None:
        super()
        self.name = name
    
    def SendMessage(self, request, context):
        if(request.msg):
            print(f'\u001b[1;36m[{request.time}] {request.sender}>\u001b[0m {request.msg}')
        return chat_pb2.NullMsg()
    
    def GetInformation(self, request, context):
        return chat_pb2.Message(time=datetime.now().strftime(TIME_FORMAT), sender=self.name, msg='OK')

"""
Class that defines a Peer. A peer can connect to other peers to chat, while also listening to other peers to chat
"""
class Peer:
    def __init__(self, name: str, sendingPort: int, listeningPort: int) -> None:
        self.name = name 
        self.sendingPort = sendingPort
        self.listeningPort = listeningPort
    
    def listen(self) -> None:
        server = grpc.server(futures.ThreadPoolExecutor(max_workers=5))
        chat_pb2_grpc.add_ChattingServiceServicer_to_server(ChattingServiceServicer(self.name), server)
        server.add_insecure_port("[::]:" + str(self.listeningPort))
        server.start()
        
        server.wait_for_termination()

    """
    Function that defines the chatting mechanism between peers.
    """ 
    def chat(self) -> None:
        with grpc.insecure_channel(f'localhost:{self.sendingPort}') as channel:
            stub = chat_pb2_grpc.ChattingServiceStub(channel)

            peerName = None
            connected = False 
            print('\u001b[1;94mWaiting for other peer to connect...\u001b[0m')
            while not connected:
                try:
                    peerName = stub.GetInformation(chat_pb2.NullMsg()).sender
                    connected = True
                except:
                    sleep(3)
            
            print(f'\n\n\u001b[1;94mWelcome, \u001b[1;32m{self.name}\u001b[1;94m. You are chatting with \u001b[1;36m{peerName}\u001b[1;94m.\u001b[0m\n\n')

            while True:
                message = input()
                try:
                    if(message):
                        stub.SendMessage(chat_pb2.Message(time=datetime.now().strftime(TIME_FORMAT), sender=self.name, msg=message))
                        print(f'\u001b[1A\u001b[2K\u001b[1;32m[{datetime.now().strftime(TIME_FORMAT)}] {self.name}>\u001b[0m {message}')
                except:
                    print('\u001b[1;94mOther peer unreachable. Future messages may be lost.\u001b[0m')

"""
Execution of the main function
The name of the peer, the sendingPort and the listeningPort are passed as an argument when executing the script
The listener and the chatter are started as Threads
"""
if __name__ == "__main__":
    peer = Peer(sys.argv[1], int(sys.argv[2]), int(sys.argv[3]))

    listener = Thread(target=peer.listen)
    chatter = Thread(target=peer.chat)

    listener.start()
    chatter.start()
    listener.join()
    chatter.join()