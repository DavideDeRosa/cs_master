\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lipsum}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage[margin=1in]{geometry}
\usepackage{titlesec}
\usepackage{parskip}
\usepackage{tcolorbox}

\titleformat{\section}
{\LARGE\bfseries}{\thesection}{1em}{}

\titleformat{\subsection}
{\Large\bfseries}{\thesection}{1em}{}

\begin{document}

\pagestyle{empty}

\section*{Domande esame}
\large

\subsection*{Programmazione ad attori, funzionale ed Erlang}
\textbf{Domanda}\\
Definizione di paradigma ad attori

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Differenze fra il paradigma ad attori e quello ad agenti

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Punti di forza e di debolezza del paradigma ad attori

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Erlang: genesi, storia, obiettivi, punti di forza

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Definizione di paradigma funzionale

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Punti di forza e di debolezza del paradigma funzionale

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Definizione di funzioni higher-order

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Definizione di oggetti di prima classe

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Immutabilità: vantaggi e svantaggi

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Strictness vs lazyness

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
La rappresentazione dei dati nei linguaggi funzionali

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
La garbage collection nei linguaggi funzionali

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Pattern, pattern matching e guardie

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Hot-swap del codice in Erlang: come invocarlo e come è implementato

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Chiamate di funzione di coda, funzioni tail ricorsive e relativa ottimizzazione

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Costrutti tipici dei linguaggi di programmazione funzionale in sintassi Erlang e loro uso: pattern matching, case analysis, local function declaration (sia nella versione ricorsiva che in quella non ricorsiva), list comprehension

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Record vs tuple: differenze (o loro mancanza) a run-time, vantaggi e svantaggi, implementazione di record tramite macro

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Macro igieniche vs non-igieniche: il problema della cattura dei nomi

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Esempi di comandi implementabili tramite macro ma non tramite funzioni in un linguaggio di programmazione eager (call-by-value). Possibili workaround cambiando la sintassi e passando funzioni invece di espressioni.

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Le eccezioni: il costrutto try .. of .. catch .. after. Attenzione alla semantica: cosa accade se un'eccezione viene sollevata nel try? Se viene sollevata in un ramo dopo l'of? In un ramo dentro al catch? Nell'after? Se viene sollevata sia nel catch che nel try? Etc.

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Come vengono implementate le eccezioni? Come interferiscono con la tail-call optimization?

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Costrutti per la programmazione concorrente: send asincrona, receive asincrona, spawning di un nuovo processo, link/unlink, monitor/demonitor e intercettamento degli EXIT message per processi linked/monitored

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Registrazione/pubblicazione del PID su un singolo nodo e in ambiente distribuito

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Mobilità del codice: in quali situazioni migrare il codice verso un altro nodo è consigliabile? Come si può implementare in Erlang la migrazione del codice?

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Come stabilire una connessione fra più nodi Erlang e come registrare PID in modo da contattare attori in esecuzione su altri nodi.

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Il modello di sicurezza di Erlang basato su token (e perchè per lanciare due nodi su una stessa macchina non è necessario specificare alcun token)

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Comunicazione con librerie e processi esterni: il meccanismo basato su porte.

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Context switch, cooperative multi-tasking, preemptive multi-tasking

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Implementazione del preemptive multi-tasking in Erlang senza far ricorso a interrupt hardware

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Implementazione di Erlang: strutture dati usate a run-time per rappresentare il set di processi in esecuzione e la loro memoria.

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Erlang Term Storage (ETS)

\textbf{Risposta}\\
ciao
\vspace{14pt}\\

\subsection*{Garbage Collection}
\textbf{Domanda}\\
Definizione di garbage collection

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Vantaggi e svantaggi della garbage collection

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
La tecnica del reference counting per l'implementazione di garbage collection

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Algoritmi mark\&sweep per la garbage collection

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Gestione dei puntatori dallo heap young allo heap old

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Gestione dei puntatori dallo heap old allo heap young quando necessaria (e sapere quando lo è)

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Definizione di paradigma ad attori

\textbf{Risposta}\\
ciao
\vspace{14pt}\\

\subsection*{Funzioni e chiusure}
\textbf{Domanda}\\
Cosa significa che in un linguaggio di programmazione le funzioni sono entità di prima classe? Argomentare facendo esempi e contro-esempi.

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Che cos’è una chiusura?

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Perché sono utili le chiusure?

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Come sono realizzate le chiusure?

\textbf{Risposta}\\
ciao
\vspace{14pt}\\

\subsection*{Oggetti, classi e trait}
\textbf{Domanda}\\
Il modello di programmazione a oggetti: varianti, nozioni fondamentali, implementazione, limiti.

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Metodi in Go, cosa sono, come funzionano.

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Scrivi il metodo Go che implementa l’operazione X per la struttura dati S.

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Cos’è il duck typing? Come si concretizza in un linguaggio come Go?

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Interfacce in Go, cosa sono, come funzionano (implementazione), esempi.

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
C’è distinzione tra binding statico e binding dinamico in Go/Rust? Fare (contro-)esempi.

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Argomenti e variabili di tipo interfaccia in Go. Come sono implementati?

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Trait in Rust, cosa sono, come funzionano

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Trait come vincoli di parametri di tipo: a cosa servono? Fare esempi.

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Analogie e differenze tra oggetti, interfacce, trait, chiusure.

\textbf{Risposta}\\
ciao
\vspace{14pt}\\

\subsection*{Type classes}
\textbf{Domanda}\\
Type classes di Haskell: motivazione, definizione, implementazione, esempi.

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Type classes su costruttori di tipo: esempi.

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Cosa ci si può aspettare da una funzione F che ha tipo T?

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Qual è il tipo più generale che si può dare alla funzione F? (codice di F fornito o da realizzare)

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Come sono implementate le type classes in Haskell? Analogie e differenze tra type classes, interfacce, trait.

\textbf{Risposta}\\
ciao
\vspace{14pt}\\

\subsection*{Monadi}
\textbf{Domanda}\\
Monadi in Haskell: motivazione, definizione, implementazione, esempi.

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Leggi di una monade: enunciato, dimostrazione per monadi specifiche.

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Scrittura di funzioni con monadi

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Implementazione di monadi (quelle discusse a lezione, presentate nelle slide o nell’articolo di Wadler, altre definite “al volo”)

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Il costrutto do: significato, uso, esempi, traduzione con >>= e >>.

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Trasformazioni di monadi: motivazione, definizione, implementazione, esempi.

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Definizione di monadi per mezzo di monad transformers. Differenze tra monadi ottenute applicando trasformazioni in ordini diversi.

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Lifting di operazioni.

\textbf{Risposta}\\
ciao
\vspace{14pt}\\

\subsection*{Rust}
\textbf{Domanda}\\
Caratteristiche e motivazioni per Rust

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Ownership e suo trasferimento

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Borrowing mutabile e immutabile; references

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Slices (mutabili e immutabili)

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Lifetimes, loro dichiarazione e loro uso come bound per il polimorfismo parametrico

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Smart pointers: Box, Rc, RefCell, Arc, Mutex, ...

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Implementazione di uno smart pointer

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Chiusure in Rust (e loro interazione con l'ownership e il borrowing)

\textbf{Risposta}\\
ciao
\vspace{14pt}\\

\subsection*{GADT}
\textbf{Domanda}\\
Sintassi dei Generalized Abstract Data Types e loro rappresentazione a run-time

\textbf{Risposta}\\
ciao
\vspace{14pt}\\
\textbf{Domanda}\\
Applicazioni dei GADT: imposizione di invarianti alle strutture dati e relative semplificazioni del codice; ad-hoc polymorphism (e.g. implementazione di una printf); tipo eq

\textbf{Risposta}\\
ciao
\vspace{14pt}\\

\end{document}